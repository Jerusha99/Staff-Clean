import 'dart:async';
import 'package:firebase_database/firebase_database.dart';
import '../models/recurring_task.dart';
import '../models/cleaning_task.dart';
import '../models/app_notification.dart';
import 'notification_service.dart';
import 'firebase_service.dart';

class TaskSchedulingService {
  final FirebaseDatabase _database = FirebaseDatabase.instance;
  final FirebaseService _firebaseService = FirebaseService();
  final NotificationService _notificationService = NotificationService();
  Timer? _dailyCheckTimer;
  
  // Start the automatic task generation service
  void startTaskScheduling() {
    // Run every hour to check for new tasks to generate
    _dailyCheckTimer = Timer.periodic(const Duration(hours: 1), (timer) {
      _generateRecurringTasks();
    });
    
    // Also run immediately on start
    _generateRecurringTasks();
  }
  
  // Stop the automatic task generation service
  void stopTaskScheduling() {
    _dailyCheckTimer?.cancel();
    _dailyCheckTimer = null;
  }
  
  // Generate tasks from all active recurring tasks
  Future<void> _generateRecurringTasks() async {
    try {
      final recurringTasks = await _getActiveRecurringTasks();
      final currentDate = DateTime.now();
      
      for (final recurringTask in recurringTasks) {
        if (recurringTask.shouldGenerateTask(currentDate)) {
          await _generateTaskFromRecurring(recurringTask);
        }
      }
    } catch (e) {
      // TODO: Implement proper error logging
    }
  }
  
  // Get all active recurring tasks
  Future<List<RecurringTask>> _getActiveRecurringTasks() async {
    final snapshot = await _database
        .ref('recurring_tasks')
        .orderByChild('status')
        .equalTo('active')
        .once();
    
    final List<RecurringTask> tasks = [];
    final data = snapshot.snapshot.value;
    
    if (data != null && data is Map) {
      data.forEach((key, value) {
        tasks.add(RecurringTask.fromMap(key, Map<String, dynamic>.from(value as Map)));
      });
    }
    
    return tasks;
  }
  
  // Generate a single task from a recurring task
  Future<void> _generateTaskFromRecurring(RecurringTask recurringTask) async {
    try {
      // Create the cleaning task
      final cleaningTask = recurringTask.generateCleaningTask();
      
      // Add the task to the database
      await _firebaseService.addTask(cleaningTask);
      
      // Update the recurring task
      await _updateRecurringTaskAfterGeneration(recurringTask);
      
      // Send notification to assigned staff
      await _sendTaskNotification(cleaningTask);
      
      // Log the automatic generation
      await _logTaskGeneration(recurringTask, cleaningTask);
      
    } catch (e) {
      // TODO: Implement proper error logging
    }
  }
  
  // Update recurring task after generating a task
  Future<void> _updateRecurringTaskAfterGeneration(RecurringTask recurringTask) async {
    final updatedTask = recurringTask.copyWith(
      lastGeneratedDate: DateTime.now(),
      currentOccurrences: recurringTask.currentOccurrences + 1,
    );
    
    await _database.ref('recurring_tasks').child(recurringTask.id).update(updatedTask.toMap());
  }
  
  // Send notification to assigned staff member
  Future<void> _sendTaskNotification(CleaningTask task) async {
    // Create notification in database
    final notification = AppNotification(
      id: '', // Will be generated by Firebase
      title: 'New Task Assigned',
      message: 'You have been assigned a new task: ${task.title}',
      recipientUserId: task.assignedTo,
      timestamp: DateTime.now(),
      read: false,
    );
    
    await _firebaseService.addNotification(notification);
    
    // Send push notification
    await _notificationService.showNotification(
      'New Task Assigned',
      'You have been assigned a new task: ${task.title}',
    );
  }
  
  // Log automatic task generation
  Future<void> _logTaskGeneration(RecurringTask recurringTask, CleaningTask generatedTask) async {
    await _firebaseService.logAdminActivity('Automatic Task Generated', {
      'recurringTaskId': recurringTask.id,
      'recurringTaskTitle': recurringTask.title,
      'generatedTaskId': generatedTask.id,
      'assignedTo': generatedTask.assignedTo,
      'assignedToName': generatedTask.assignedToName,
      'frequency': recurringTask.frequency.name,
      'generationDate': DateTime.now().toIso8601String(),
    });
  }
  
  // Add a new recurring task
  Future<void> addRecurringTask(RecurringTask recurringTask) async {
    await _database.ref('recurring_tasks').push().set(recurringTask.toMap());
    
    // Log the creation
    await _firebaseService.logAdminActivity('Created Recurring Task', {
      'recurringTaskId': recurringTask.id,
      'title': recurringTask.title,
      'assignedTo': recurringTask.assignedTo,
      'frequency': recurringTask.frequency.name,
      'startDate': recurringTask.startDate.toIso8601String(),
    });
  }
  
  // Update a recurring task
  Future<void> updateRecurringTask(String taskId, Map<String, dynamic> updates) async {
    await _database.ref('recurring_tasks').child(taskId).update(updates);
    
    // Log the update
    await _firebaseService.logAdminActivity('Updated Recurring Task', {
      'recurringTaskId': taskId,
      'updates': updates,
    });
  }
  
  // Delete a recurring task
  Future<void> deleteRecurringTask(String taskId) async {
    await _database.ref('recurring_tasks').child(taskId).remove();
    
    // Log the deletion
    await _firebaseService.logAdminActivity('Deleted Recurring Task', {
      'recurringTaskId': taskId,
    });
  }
  
  // Get all recurring tasks (for admin)
  Stream<List<RecurringTask>> getAllRecurringTasks() {
    return _database.ref('recurring_tasks').onValue.map((event) {
      final List<RecurringTask> tasks = [];
      final data = event.snapshot.value;
      
      if (data != null && data is Map) {
        data.forEach((key, value) {
          tasks.add(RecurringTask.fromMap(key, Map<String, dynamic>.from(value as Map)));
        });
      }
      
      // Sort by creation date (newest first)
      tasks.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      return tasks;
    });
  }
  
  // Get recurring tasks for a specific staff member
  Stream<List<RecurringTask>> getStaffRecurringTasks(String staffId) {
    return _database
        .ref('recurring_tasks')
        .orderByChild('assignedTo')
        .equalTo(staffId)
        .onValue
        .map((event) {
      final List<RecurringTask> tasks = [];
      final data = event.snapshot.value;
      
      if (data != null && data is Map) {
        data.forEach((key, value) {
          tasks.add(RecurringTask.fromMap(key, Map<String, dynamic>.from(value as Map)));
        });
      }
      
      // Sort by creation date (newest first)
      tasks.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      return tasks;
    });
  }
  
  // Get a single recurring task
  Future<RecurringTask?> getRecurringTask(String taskId) async {
    final snapshot = await _database.ref('recurring_tasks').child(taskId).get();
    
    if (snapshot.exists) {
      return RecurringTask.fromMap(taskId, Map<String, dynamic>.from(snapshot.value as Map));
    }
    
    return null;
  }
  
  // Pause a recurring task
  Future<void> pauseRecurringTask(String taskId) async {
    await updateRecurringTask(taskId, {'status': 'paused'});
  }
  
  // Resume a recurring task
  Future<void> resumeRecurringTask(String taskId) async {
    await updateRecurringTask(taskId, {'status': 'active'});
  }
  
  // Cancel a recurring task
  Future<void> cancelRecurringTask(String taskId) async {
    await updateRecurringTask(taskId, {'status': 'cancelled'});
  }
  
  // Get upcoming task generations for the next 7 days
  Future<List<Map<String, dynamic>>> getUpcomingTaskGenerations() async {
    final recurringTasks = await _getActiveRecurringTasks();
    final List<Map<String, dynamic>> upcomingGenerations = [];
    final now = DateTime.now();
    
    for (final task in recurringTasks) {
      final nextDueDate = task.getNextDueDate(now);
      
      if (nextDueDate != null) {
        final daysUntil = nextDueDate.difference(now).inDays;
        
        if (daysUntil <= 7) {
          upcomingGenerations.add({
            'task': task,
            'nextDueDate': nextDueDate,
            'daysUntil': daysUntil,
          });
        }
      }
    }
    
    // Sort by days until
    upcomingGenerations.sort((a, b) => a['daysUntil'].compareTo(b['daysUntil']));
    
    return upcomingGenerations;
  }
  
  // Manually trigger task generation for a specific recurring task
  Future<void> manuallyGenerateTask(String recurringTaskId) async {
    final recurringTask = await getRecurringTask(recurringTaskId);
    
    if (recurringTask != null && recurringTask.status == RecurringTaskStatus.active) {
      await _generateTaskFromRecurring(recurringTask);
    }
  }
  
  // Get statistics about recurring tasks
  Future<Map<String, dynamic>> getRecurringTaskStatistics() async {
    final snapshot = await _database.ref('recurring_tasks').once();
    final data = snapshot.snapshot.value;
    
    int totalTasks = 0;
    int activeTasks = 0;
    int pausedTasks = 0;
    int cancelledTasks = 0;
    int totalGenerated = 0;
    
    if (data != null && data is Map) {
      data.forEach((key, value) {
        final task = RecurringTask.fromMap(key, Map<String, dynamic>.from(value as Map));
        totalTasks++;
        totalGenerated += task.currentOccurrences;
        
        switch (task.status) {
          case RecurringTaskStatus.active:
            activeTasks++;
            break;
          case RecurringTaskStatus.paused:
            pausedTasks++;
            break;
          case RecurringTaskStatus.cancelled:
            cancelledTasks++;
            break;
        }
      });
    }
    
    return {
      'totalTasks': totalTasks,
      'activeTasks': activeTasks,
      'pausedTasks': pausedTasks,
      'cancelledTasks': cancelledTasks,
      'totalGenerated': totalGenerated,
    };
  }
}